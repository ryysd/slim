<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>cap</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.1' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/334.html#L729'>cap</a>               729 src/hyperlink.c     printf("&gt;&gt;&gt;&gt; sht %p num %d cap %d\n", sht, n, sht-&gt;cap);</span>
<span class='curline'><a href='../S/334.html#L730'>cap</a>               730 src/hyperlink.c     for (i = 0; i &lt; sht-&gt;cap; i++) {</span>
<span class='curline'><a href='../S/334.html#L752'>cap</a>               752 src/hyperlink.c     printf("&gt;&gt;&gt;&gt;  hs %p num %d cap %d\n", hs, n, hs-&gt;cap);</span>
<span class='curline'><a href='../S/334.html#L753'>cap</a>               753 src/hyperlink.c     for (i = 0; i &lt; hs-&gt;cap; i++) {</span>
<span class='curline'><a href='../S/351.html#L290'>cap</a>               290 src/load.c       unsigned int loc, cap;         /* 書き込み位置とbyte_seqのキャパシティ */</span>
<span class='curline'><a href='../S/351.html#L304'>cap</a>               304 src/load.c       c-&gt;cap = 256;</span>
<span class='curline'><a href='../S/351.html#L305'>cap</a>               305 src/load.c       c-&gt;byte_seq = LMN_NALLOC(BYTE, c-&gt;cap);</span>
<span class='curline'><a href='../S/351.html#L319'>cap</a>               319 src/load.c       c-&gt;cap *= 2;</span>
<span class='curline'><a href='../S/351.html#L320'>cap</a>               320 src/load.c       c-&gt;byte_seq = LMN_REALLOC(BYTE, c-&gt;byte_seq, c-&gt;cap);</span>
<span class='curline'><a href='../S/351.html#L326'>cap</a>               326 src/load.c         while ((CONTEXT)-&gt;loc + sizeof(TYPE) &gt;= (CONTEXT)-&gt;cap) {    \</span>
<span class='curline'><a href='../S/351.html#L341'>cap</a>               341 src/load.c           while ((CONTEXT)-&gt;loc + sizeof(TYPE) &gt;= (CONTEXT)-&gt;cap) {  \</span>
<span class='curline'><a href='../S/351.html#L353'>cap</a>               353 src/load.c           while ((LOC) + sizeof(TYPE) &gt;= (CONTEXT)-&gt;cap) {           \</span>
<span class='curline'><a href='../S/351.html#L536'>cap</a>               536 src/load.c       runtime_rule = lmn_rule_make(c-&gt;byte_seq, c-&gt;cap, ANONYMOUS);</span>
<span class='curline'><a href='../S/357.html#L2753'>cap</a>              2753 src/membrane.c   memset(vec-&gt;tbl, 0, sizeof(atomvec_data *) * vec-&gt;cap);</span>
<span class='curline'><a href='../S/365.html#L152'>cap</a>               152 src/rule.c       ruleset-&gt;cap = init_size;</span>
<span class='curline'><a href='../S/365.html#L176'>cap</a>               176 src/rule.c       if (ruleset-&gt;num == ruleset-&gt;cap) {</span>
<span class='curline'><a href='../S/365.html#L177'>cap</a>               177 src/rule.c         ruleset-&gt;cap = (ruleset-&gt;cap * 2);</span>
<span class='curline'><a href='../S/365.html#L178'>cap</a>               178 src/rule.c         ruleset-&gt;rules = LMN_REALLOC(LmnRule, ruleset-&gt;rules, ruleset-&gt;cap);</span>
<span class='curline'><a href='../S/366.html#L143'>cap</a>               143 src/rule.h       int num, cap;           /* # of rules, and # of capacity */</span>
<span class='curline'><a href='../S/386.html#L259'>cap</a>               259 src/translate.c   v.cap = size;</span>
<span class='curline'><a href='../S/393.html#L93'>cap</a>                93 src/utility/internal_hash.c   ht-&gt;cap = round2up(init_size);</span>
<span class='curline'><a href='../S/393.html#L94'>cap</a>                94 src/utility/internal_hash.c   ht-&gt;tbl = (HashEntry *)malloc(sizeof(struct HashEntry) * ht-&gt;cap);</span>
<span class='curline'><a href='../S/393.html#L95'>cap</a>                95 src/utility/internal_hash.c   memset(ht-&gt;tbl, 0xffU, sizeof(struct HashEntry) * ht-&gt;cap);</span>
<span class='curline'><a href='../S/393.html#L146'>cap</a>               146 src/utility/internal_hash.c   if (ht-&gt;num &gt; ht-&gt;cap * LOAD_FACTOR) {</span>
<span class='curline'><a href='../S/393.html#L152'>cap</a>               152 src/utility/internal_hash.c   memset(ht-&gt;tbl, 0xffU, sizeof(struct HashEntry) * ht-&gt;cap);</span>
<span class='curline'><a href='../S/393.html#L158'>cap</a>               158 src/utility/internal_hash.c   HashKeyType increment = (key | 1) &amp; (ht-&gt;cap-1);</span>
<span class='curline'><a href='../S/393.html#L160'>cap</a>               160 src/utility/internal_hash.c   for (probe = INT_HASH(key) &amp; (ht-&gt;cap-1);</span>
<span class='curline'><a href='../S/393.html#L162'>cap</a>               162 src/utility/internal_hash.c        probe = (probe + increment) &amp; (ht-&gt;cap-1)) {</span>
<span class='curline'><a href='../S/393.html#L171'>cap</a>               171 src/utility/internal_hash.c   unsigned int i, cap;</span>
<span class='curline'><a href='../S/393.html#L173'>cap</a>               173 src/utility/internal_hash.c   if (ht-&gt;cap == MAX_CAP) {</span>
<span class='curline'><a href='../S/393.html#L178'>cap</a>               178 src/utility/internal_hash.c   cap = ht-&gt;cap;</span>
<span class='curline'><a href='../S/393.html#L180'>cap</a>               180 src/utility/internal_hash.c   ht-&gt;cap &lt;&lt;= 1;</span>
<span class='curline'><a href='../S/393.html#L181'>cap</a>               181 src/utility/internal_hash.c   ht-&gt;tbl = (HashEntry *)malloc(sizeof(struct HashEntry) *  ht-&gt;cap);</span>
<span class='curline'><a href='../S/393.html#L182'>cap</a>               182 src/utility/internal_hash.c   memset(ht-&gt;tbl, 0xffU, sizeof(struct HashEntry) * ht-&gt;cap);</span>
<span class='curline'><a href='../S/393.html#L184'>cap</a>               184 src/utility/internal_hash.c   for (i = 0; i &lt; cap; i++) {</span>
<span class='curline'><a href='../S/393.html#L199'>cap</a>               199 src/utility/internal_hash.c   if (ht-&gt;cap &gt; 0 &amp;&amp; ht-&gt;tbl[iter.i].key &gt;= DELETED_KEY) {</span>
<span class='curline'><a href='../S/393.html#L207'>cap</a>               207 src/utility/internal_hash.c   while (++iter-&gt;i &lt; iter-&gt;ht-&gt;cap &amp;&amp;</span>
<span class='curline'><a href='../S/393.html#L215'>cap</a>               215 src/utility/internal_hash.c   set-&gt;cap = round2up(init_size);</span>
<span class='curline'><a href='../S/393.html#L216'>cap</a>               216 src/utility/internal_hash.c   set-&gt;tbl = (HashKeyType *)malloc(sizeof(HashKeyType) * set-&gt;cap);</span>
<span class='curline'><a href='../S/393.html#L217'>cap</a>               217 src/utility/internal_hash.c   memset(set-&gt;tbl, 0xffU, sizeof(HashKeyType) * set-&gt;cap);</span>
<span class='curline'><a href='../S/393.html#L246'>cap</a>               246 src/utility/internal_hash.c   unsigned int i, cap;</span>
<span class='curline'><a href='../S/393.html#L248'>cap</a>               248 src/utility/internal_hash.c   if (set-&gt;cap == MAX_CAP) {</span>
<span class='curline'><a href='../S/393.html#L253'>cap</a>               253 src/utility/internal_hash.c   cap = set-&gt;cap;</span>
<span class='curline'><a href='../S/393.html#L255'>cap</a>               255 src/utility/internal_hash.c   set-&gt;cap &lt;&lt;= 1;</span>
<span class='curline'><a href='../S/393.html#L256'>cap</a>               256 src/utility/internal_hash.c   set-&gt;tbl = (HashKeyType *)malloc(sizeof(HashKeyType) *  set-&gt;cap);</span>
<span class='curline'><a href='../S/393.html#L257'>cap</a>               257 src/utility/internal_hash.c   memset(set-&gt;tbl, 0xffU, sizeof(HashKeyType) * set-&gt;cap);</span>
<span class='curline'><a href='../S/393.html#L259'>cap</a>               259 src/utility/internal_hash.c   for(i = 0; i &lt; cap; i++) {</span>
<span class='curline'><a href='../S/393.html#L277'>cap</a>               277 src/utility/internal_hash.c   if(set-&gt;num &gt; set-&gt;cap * LOAD_FACTOR) {</span>
<span class='curline'><a href='../S/393.html#L283'>cap</a>               283 src/utility/internal_hash.c   memset(set-&gt;tbl, 0xffU, sizeof(HashKeyType) * set-&gt;cap);</span>
<span class='curline'><a href='../S/393.html#L302'>cap</a>               302 src/utility/internal_hash.c   if(set-&gt;cap &gt; 0 &amp;&amp; set-&gt;tbl[it.i] &gt;= DELETED_KEY) {</span>
<span class='curline'><a href='../S/393.html#L309'>cap</a>               309 src/utility/internal_hash.c   while (++it-&gt;i &lt; it-&gt;set-&gt;cap &amp;&amp; it-&gt;set-&gt;tbl[it-&gt;i] &gt;=  DELETED_KEY);</span>
<span class='curline'><a href='../S/393.html#L315'>cap</a>               315 src/utility/internal_hash.c   HashKeyType increment = (key | 1) &amp; (set-&gt;cap-1);</span>
<span class='curline'><a href='../S/393.html#L317'>cap</a>               317 src/utility/internal_hash.c   for (probe = INT_HASH(key) &amp; (set-&gt;cap-1);</span>
<span class='curline'><a href='../S/393.html#L319'>cap</a>               319 src/utility/internal_hash.c        probe = (probe + increment) &amp; (set-&gt;cap-1)) {</span>
<span class='curline'><a href='../S/394.html#L54'>cap</a>                54 src/utility/internal_hash.h   unsigned int cap, num;</span>
<span class='curline'><a href='../S/394.html#L79'>cap</a>                79 src/utility/internal_hash.h #define hashtbliter_isend(I) ((I)-&gt;i &gt;= (I)-&gt;ht-&gt;cap)</span>
<span class='curline'><a href='../S/394.html#L84'>cap</a>                84 src/utility/internal_hash.h   unsigned int cap, num;</span>
<span class='curline'><a href='../S/394.html#L105'>cap</a>               105 src/utility/internal_hash.h #define hashsetiter_isend(I) ((I)-&gt;i &gt;= (I)-&gt;set-&gt;cap)</span>
<span class='curline'><a href='../S/394.html#L109'>cap</a>               109 src/utility/internal_hash.h   return (sizeof(struct HashEntry) * ht-&gt;cap);</span>
<span class='curline'><a href='../S/402.html#L244'>cap</a>               244 src/utility/queue.c     DEQ_DEC(i, deq-&gt;cap);</span>
<span class='curline'><a href='../S/402.html#L263'>cap</a>               263 src/utility/queue.c                 DEQ_DEC(i, deq-&gt;cap);</span>
<span class='curline'><a href='../S/403.html#L96'>cap</a>                96 src/utility/queue.h   unsigned int head, tail, cap;</span>
<span class='curline'><a href='../S/403.html#L103'>cap</a>               103 src/utility/queue.h #define deq_cap(V)       ((V)-&gt;cap)</span>
<span class='curline'><a href='../S/403.html#L108'>cap</a>               108 src/utility/queue.h                           : (V)-&gt;cap  - (V)-&gt;head + (V)-&gt;tail - 1)</span>
<span class='curline'><a href='../S/403.html#L143'>cap</a>               143 src/utility/queue.h   deq-&gt;cap  = init_size;</span>
<span class='curline'><a href='../S/403.html#L156'>cap</a>               156 src/utility/queue.h   unsigned int old = deq-&gt;cap;</span>
<span class='curline'><a href='../S/403.html#L157'>cap</a>               157 src/utility/queue.h   deq-&gt;cap *= 2;</span>
<span class='curline'><a href='../S/403.html#L158'>cap</a>               158 src/utility/queue.h   deq-&gt;tbl = LMN_REALLOC(LmnWord, deq-&gt;tbl, deq-&gt;cap);</span>
<span class='curline'><a href='../S/403.html#L170'>cap</a>               170 src/utility/queue.h   if(deq_num(deq) == deq-&gt;cap - 1) {</span>
<span class='curline'><a href='../S/403.html#L174'>cap</a>               174 src/utility/queue.h   DEQ_DEC(deq-&gt;head, deq-&gt;cap);</span>
<span class='curline'><a href='../S/403.html#L179'>cap</a>               179 src/utility/queue.h   if(deq_num(deq) == deq-&gt;cap - 1) {</span>
<span class='curline'><a href='../S/403.html#L183'>cap</a>               183 src/utility/queue.h   DEQ_INC(deq-&gt;tail, deq-&gt;cap);</span>
<span class='curline'><a href='../S/403.html#L191'>cap</a>               191 src/utility/queue.h   DEQ_INC(deq-&gt;head, deq-&gt;cap);</span>
<span class='curline'><a href='../S/403.html#L198'>cap</a>               198 src/utility/queue.h   DEQ_DEC(deq-&gt;tail, deq-&gt;cap);</span>
<span class='curline'><a href='../S/403.html#L205'>cap</a>               205 src/utility/queue.h   return deq-&gt;tbl[DEQ_INC(x, deq-&gt;cap)];</span>
<span class='curline'><a href='../S/403.html#L210'>cap</a>               210 src/utility/queue.h   return deq-&gt;tbl[DEQ_DEC(x, deq-&gt;cap)];</span>
<span class='curline'><a href='../S/403.html#L246'>cap</a>               246 src/utility/queue.h   fprintf(f, "cap=%u, head=%u, tail=%u, num=%u\n[", deq-&gt;cap, deq-&gt;head, deq-&gt;tail, deq_num(deq));</span>
<span class='curline'><a href='../S/403.html#L247'>cap</a>               247 src/utility/queue.h   for (i = 0; i &lt; deq-&gt;cap; i++) fprintf(f, "%lu, ", deq-&gt;tbl[i]);</span>
<span class='curline'><a href='../S/408.html#L48'>cap</a>                48 src/utility/vector.c   if (vec-&gt;num &lt;= vec-&gt;cap/2) {</span>
<span class='curline'><a href='../S/408.html#L76'>cap</a>                76 src/utility/vector.c   while (size &gt; vec-&gt;cap) {</span>
<span class='curline'><a href='../S/409.html#L46'>cap</a>                46 src/utility/vector.h   unsigned int num, cap;</span>
<span class='curline'><a href='../S/409.html#L53'>cap</a>                53 src/utility/vector.h #define vec_cap(V)      ((V)-&gt;cap)</span>
<span class='curline'><a href='../S/409.html#L84'>cap</a>                84 src/utility/vector.h   vec-&gt;cap = init_size;</span>
<span class='curline'><a href='../S/409.html#L97'>cap</a>                97 src/utility/vector.h   vec-&gt;cap *= 2;</span>
<span class='curline'><a href='../S/409.html#L98'>cap</a>                98 src/utility/vector.h   vec-&gt;tbl = LMN_REALLOC(LmnWord, vec-&gt;tbl, vec-&gt;cap);</span>
<span class='curline'><a href='../S/409.html#L103'>cap</a>               103 src/utility/vector.h   if(vec-&gt;num == vec-&gt;cap) {</span>
<span class='curline'><a href='../S/409.html#L112'>cap</a>               112 src/utility/vector.h   vec-&gt;cap /= 2;</span>
<span class='curline'><a href='../S/409.html#L113'>cap</a>               113 src/utility/vector.h   vec-&gt;tbl = LMN_REALLOC(LmnWord, vec-&gt;tbl, vec-&gt;cap);</span>
<span class='curline'><a href='../S/409.html#L123'>cap</a>               123 src/utility/vector.h   if (vec-&gt;num &lt;= vec-&gt;cap/2 &amp;&amp; vec-&gt;cap &gt; 1024) {</span>
<span class='curline'><a href='../S/409.html#L138'>cap</a>               138 src/utility/vector.h   LMN_ASSERT(index &lt; vec-&gt;cap);</span>
<span class='curline'><a href='../S/410.html#L159'>cap</a>               159 src/utility/visitlog.c   p-&gt;cap = size;</span>
<span class='curline'><a href='../S/410.html#L161'>cap</a>               161 src/utility/visitlog.c   p-&gt;tbl = LMN_NALLOC(BYTE, p-&gt;cap);</span>
<span class='curline'><a href='../S/410.html#L162'>cap</a>               162 src/utility/visitlog.c   memset(p-&gt;tbl, SPROC_TBL_INIT_V, sizeof(BYTE) * p-&gt;cap);</span>
<span class='curline'><a href='../S/410.html#L206'>cap</a>               206 src/utility/visitlog.c   l-&gt;cap = size;</span>
<span class='curline'><a href='../S/410.html#L208'>cap</a>               208 src/utility/visitlog.c   l-&gt;tbl = LMN_NALLOC(struct TraceData, l-&gt;cap);</span>
<span class='curline'><a href='../S/410.html#L209'>cap</a>               209 src/utility/visitlog.c   memset(l-&gt;tbl, 0U, sizeof(struct TraceData) * l-&gt;cap);</span>
<span class='curline'><a href='../S/411.html#L255'>cap</a>               255 src/utility/visitlog.h   unsigned long n, cap;</span>
<span class='curline'><a href='../S/411.html#L304'>cap</a>               304 src/utility/visitlog.h   unsigned long org_size = p-&gt;cap;</span>
<span class='curline'><a href='../S/411.html#L305'>cap</a>               305 src/utility/visitlog.h   while (p-&gt;cap &lt;= n) p-&gt;cap *= 2;</span>
<span class='curline'><a href='../S/411.html#L306'>cap</a>               306 src/utility/visitlog.h   p-&gt;tbl = LMN_REALLOC(BYTE, p-&gt;tbl, p-&gt;cap);</span>
<span class='curline'><a href='../S/411.html#L309'>cap</a>               309 src/utility/visitlog.h          sizeof(BYTE) * (p-&gt;cap - org_size));</span>
<span class='curline'><a href='../S/411.html#L318'>cap</a>               318 src/utility/visitlog.h   if (p-&gt;cap &lt;= key) {</span>
<span class='curline'><a href='../S/411.html#L342'>cap</a>               342 src/utility/visitlog.h   if (p-&gt;cap &lt; key || p-&gt;tbl[key] == SPROC_TBL_INIT_V) return;</span>
<span class='curline'><a href='../S/411.html#L360'>cap</a>               360 src/utility/visitlog.h   if (p-&gt;cap &gt; key &amp;&amp; p-&gt;tbl[key] != SPROC_TBL_INIT_V) {</span>
<span class='curline'><a href='../S/411.html#L381'>cap</a>               381 src/utility/visitlog.h   return key &lt; p-&gt;cap &amp;&amp; p-&gt;tbl[key] != SPROC_TBL_INIT_V;</span>
<span class='curline'><a href='../S/411.html#L398'>cap</a>               398 src/utility/visitlog.h   if (p-&gt;cap &gt; key &amp;&amp; p-&gt;tbl[key] != SPROC_TBL_INIT_V) return p-&gt;tbl[key] &amp; flag;</span>
<span class='curline'><a href='../S/411.html#L416'>cap</a>               416 src/utility/visitlog.h   if (p-&gt;cap &lt;= key) {</span>
<span class='curline'><a href='../S/411.html#L437'>cap</a>               437 src/utility/visitlog.h   if (p-&gt;cap &lt;= key) {</span>
<span class='curline'><a href='../S/411.html#L541'>cap</a>               541 src/utility/visitlog.h   int cap, num;</span>
<span class='curline'><a href='../S/411.html#L637'>cap</a>               637 src/utility/visitlog.h   unsigned long org_size = l-&gt;cap;</span>
<span class='curline'><a href='../S/411.html#L638'>cap</a>               638 src/utility/visitlog.h   while (l-&gt;cap &lt;= new_size) l-&gt;cap *= 2;</span>
<span class='curline'><a href='../S/411.html#L639'>cap</a>               639 src/utility/visitlog.h   l-&gt;tbl = LMN_REALLOC(struct TraceData, l-&gt;tbl, l-&gt;cap);</span>
<span class='curline'><a href='../S/411.html#L640'>cap</a>               640 src/utility/visitlog.h   memset(l-&gt;tbl + org_size, TLOG_INIT_DATA, sizeof(struct TraceData) * (l-&gt;cap - org_size));</span>
<span class='curline'><a href='../S/411.html#L650'>cap</a>               650 src/utility/visitlog.h   if (l-&gt;cap &lt;= key) {</span>
<span class='curline'><a href='../S/411.html#L661'>cap</a>               661 src/utility/visitlog.h     LMN_ASSERT(l-&gt;cap &gt; lmn_mem_id(owner));</span>
<span class='curline'><a href='../S/411.html#L699'>cap</a>               699 src/utility/visitlog.h   if (l-&gt;cap &gt; key) {</span>
<span class='curline'><a href='../S/411.html#L707'>cap</a>               707 src/utility/visitlog.h   return (l-&gt;cap &gt; key) &amp;&amp; TLOG_IS_TRV(TLOG_FLAG(l-&gt;tbl[key]));</span>
<span class='curline'><a href='../S/456.html#L181'>cap</a>               181 src/verifier/statespace.c   ENTER__CRITICAL_SECTION(resize, st-&gt;lock, ewlock_reject_enter, env_my_thread_id(), old_cap, st-&gt;cap);</span>
<span class='curline'><a href='../S/456.html#L214'>cap</a>               214 src/verifier/statespace.c     st-&gt;cap = new_cap;</span>
<span class='curline'><a href='../S/456.html#L517'>cap</a>               517 src/verifier/statespace.c     statetable_resize(insert_dst, insert_dst-&gt;cap);</span>
<span class='curline'><a href='../S/456.html#L581'>cap</a>               581 src/verifier/statespace.c     statetable_resize(add_dst, add_dst-&gt;cap);</span>
<span class='curline'><a href='../S/456.html#L639'>cap</a>               639 src/verifier/statespace.c   st-&gt;cap          = size;</span>
<span class='curline'><a href='../S/456.html#L1021'>cap</a>              1021 src/verifier/statespace.c     size = st-&gt;cap;</span>
<span class='curline'><a href='../S/456.html#L1235'>cap</a>              1235 src/verifier/statespace.c     qsort(st-&gt;tbl, st-&gt;cap, sizeof(struct State *), statetable_cmp_state_id_gr_f);</span>
<span class='curline'><a href='../S/457.html#L106'>cap</a>               106 src/verifier/statespace.h   unsigned long    cap;</span>
<span class='curline'><a href='../S/457.html#L176'>cap</a>               176 src/verifier/statespace.h   return st-&gt;cap;</span>
<span class='curline'><a href='../S/457.html#L213'>cap</a>               213 src/verifier/statespace.h     + (tbl-&gt;cap * sizeof(State *))</span>
</pre>
</body>
</html>
