/*
 *  swp.lmn -- Sliding Window Protocol
 *
 *  @author  Takayuki Ayano
 */

% property0: ?¡ã??»ã??¸ã???¿¡????? å¿????????ç­??å¾?????

{
 wSize(3).     // ????³ã?????¤ã?
 nMAX(2).      // ????????????å¾¡ã?????????????n??????
 idMAX(3).     // ??¿¡????¿ã?æ­£å?????????????id??????
 error(false). // ????¼æ??ºã????
 
 sender{ n(0), nextId(0), sucId(0), c(0). }. // ????¿é?ä¿¡è?
 ss=rr.                                      // ????¿ã??????¿¡è·?
 rs=sr.                                      // ACK??????ä¿¡è·¯
 receiver{ n(0), expId(0). }.                // ????¿å?¿¡??
 
 // ??¿¡??: ????¿ã???¿¡ sender -> [data]
 sd@@ sender{ n(N), nextId(ID), sucId(SucID), c(C) }, nMAX(NMAX), idMAX(IDMAX), wSize(W), ss=SC
   :- C<W, C_=C+1, DN=(N+C) mod NMAX, ID_=(ID+1) mod IDMAX, int(SucID)
   |  sender{ n(N), nextId(ID_),sucId(SucID), c(C_)}, nMAX(NMAX), idMAX(IDMAX), wSize(W), ss=[data(DN,ID)|SC].
 
 // ??¿¡??: ????¿å?¿¡ï¼?CK?????äº????????????? [data] -> receiver -> [ack]
 rs@@ receiver{ n(N), expId(EID) }, nMAX(NMAX), idMAX(IDMAX), SC=[data(DN,ID)|rr], rs=RC
   :- N=:=DN, EID=:=ID, N_=(N+1) mod NMAX, EID_=(EID+1) mod IDMAX
    | receiver{ n(N_),expId(EID_)}, nMAX(NMAX), idMAX(IDMAX), SC=rr, rs=[ack(DN)|RC].
 
 // ??¿¡??: ????¿å?¿¡ï¼?CK???????¿¡??????????¼ã????å¤±æ??? [data] -> receiver -> [ack]
 ru@@ receiver{ n(N), expId(EID) }, SC=[data(DN,ID)|rr], rs=RC
   :- N=\=DN, int(ID), int(EID), ground(SC)
    | receiver{ n(N), expId(EID) }, ss=rr, rs=[ack(DN)|RC].
 
 // ??¿¡??: ????¿å?¿¡(æ­£ã????????¼ã??§ã??? [data] -> receiver -> error
 re@@ error(false), receiver{ n(N), expId(EID) }, SC=[data(DN,ID)|rr], rs=RC, sender{ $p[] }
   :- N=:=DN, EID=\=ID, ground(SC), ground(RC)
    | error(true).
 
 // ??¿¡??: ACK???¿¡(äº????????ACK) [ack] -> slide
 s@@ sender{ n(N), nextId(NextID), sucId(SucID), c(C) }, nMAX(NMAX), idMAX(IDMAX), RC=[ack(ACK)|sr]
  :- N=:=ACK, C>0, N_=(N+1) mod NMAX, SucID_=(SucID+1) mod IDMAX, C_=C-1, int(NextID)
   | sender{ n(N_),nextId(NextID), sucId(SucID_),c(C_)}, nMAX(NMAX), idMAX(IDMAX), RC=sr.
 
 // ??¿¡??: ACK???¿¡(????¿ã?ACK???å¤±æ??? [ack] -> reset
 r@@ sender{ n(N), nextId(NextID),sucId(SucID), c(C) }, SC=rr, RC=[ack(ACK)|sr]
  :- N=\=ACK, int(NextID), int(SucID), int(C), int(ACK), ground(SC), ground(RC)
   | sender{ n(N), nextId(SucID), sucId(SucID), c(0) }, ss=rr, rs=sr.
 
 // ??¿¡??: ?¿ã????????????[timeout] -> reset
 t@@ sender{ n(N), nextId(NextID),sucId(SucID), c(C) }, timeout
  :- int(N), int(NextID), int(SucID), int(C)
   | sender{ n(N), nextId(SucID), sucId(SucID), c(0) }.
 
 // ??¿¡è·?: ?????ACK???å¤?[data] -> [], [ack] -> []
 ld@@ X=[data(DN,ID)|Y] :- int(DN),int(ID) | X=Y.
 la@@ X=[ack(ACK)|Y] :- int(ACK) | X=Y .
}.
// ?¿ã????????????[] -> [timeout]
o@@ { error(false), $p, @p }/ :- { timeout, error(false), $p, @p }.